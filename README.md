# Паттерны проектирования (Design patterns)

[Стратегия (Strategy)](https://github.com/FessBoss/Design-Patterns/tree/main/Strategy) <br/>
**Цель:** <br/>
Взаимозаменяемость семейства классов.

**Для чего используется:** <br/>
Определение семейства классов, инкапсулирование каждого из них и организация их взаимозаменяемости.

**Пример использования** <br/>
- есть несколько родственных классов, которые отличаются поведением;
- необходимо иметь несколько вариантов поведения;
- в классе есть данные, о которых должен знать клиент;
- с помощью условных операторов в классе определено большое количество возможных поведений.

***

[Наблюдатель (Observer)](https://github.com/FessBoss/Design-Patterns/tree/main/Observer) <br/>
**Цель:** <br/>
Определение зависимости "один ко многим" между объектами.

**Для чего используется:** <br/>
Определение зависимости "один ко многим" между объектами таким образом, что при изменении состояния одного объекта 
все зависящие от него объекты были уведомлены об этом и обновились.

**Пример использования** <br/>
- когда у модели имеются два аспекта, один из которых зависит от другого. 
  Инкапсулирование этих аспектов в разные классы позволяют использовать их независимо друг от друга;
- когда один объект должен оповещать другие и не делать предположений об этих объектах;
- ослабление связи между объектами.

***

[Декоратор (Decorator)](https://github.com/FessBoss/Design-Patterns/tree/main/Decorator) <br/>
**Цель:** <br/>
Динамическое добавление новых обязанностей объекту.

**Для чего используется:** <br/>
Используется в качестве альтернативы порождению подклассов для расширения функциональности.

**Пример использования** <br/>
- динамическое и понятное клиентам добавления обязанностей объектам;
- реализация обязанностей, которые могут быть сняты с объекта;
- расширение класса путём порождения подклассов невозможно по каким-либо причинам.

***

[Фабричный метод (Factory Method)](https://github.com/FessBoss/Design-Patterns/tree/main/Factory) <br/>
**Цель:** <br/>
Создание интерфейса, который создает объект. При этом, выбор того, экземпляр какого класса создавать остается за классами,
которые имплементируют данный интерфейс.

**Для чего используется:** <br/>
Для делигирования создания экземпляров другому классу.

**Пример использования** <br/>
- заранее неизвестно, экземпляры какого класса нужно будет создавать;
- класс спроектирован таким образом, что создаваемые им объекты имеют свойство определенного класса.

***

[Абстрактная Фабрика (Abstract Factory)](https://github.com/FessBoss/Design-Patterns/tree/main/Factory) <br/>
**Цель:** <br/>
Создание интерфейса, для создания множества взаимосвязанных или взаимозависимых объектов, без жесткой привязке к конкретным
классам.

**Для чего используется:** <br/>
Для создания множеств взаимосвязанных объектов.

**Пример использования** <br/>
- система не должна зависеть от метода создания, компоновки и представления входящих в нее объектов;
- входящие взаимосвязанные объекты должны использоваться вместе;
- система должна конфигурироваться одним из множеств объектов, из которых она состоит;
- нам необходимо предоставить множество объектов, раскрывая только их интерфейсы, но не реализацию.

***

[Одиночка (Singleton)](https://github.com/FessBoss/Design-Patterns/tree/main/Singleton) <br/>
**Цель:** <br/>
Гарантировать, что у класса будет только один единственный экземпляр и к нему будет предоставлена глобальная точка 
доступа.

**Для чего используется:** <br/>
Для создания единственного экземпляра определенного класса. 

**Пример использования** <br/>
- необходим только один экземпляр класса, который доступен для всех клиентов;
- единственный экземпляр должен наследоваться путем порождения подклассов, при этом, клиенты имеют возможность работать
  с классом-наследником без модификации своего кода;

***

[Команда (Command)](https://github.com/FessBoss/Design-Patterns/tree/main/Command) <br/>
**Цель:** <br/>
Инкапсулирование запроса в объект

**Для чего используется:** <br/>
Чтобы задать параметры клиентов для обработки определенных запросов, создание очереди из этих запросов или их контроля и
поддержки отмены операций.

**Пример использования** <br/>
- параметризация объектов выполняемым действием;
- определить запрос, ставить его в очередь или выполнять его в разное время.

***

[Адаптер (Adapter)](https://github.com/FessBoss/Design-Patterns/tree/main/Adapter-Facade) <br/>
**Цель:** <br/>
Преобразование интерфейса одного класса в интерфейс того класса, который необходим клиенту.

**Для чего используется:** <br/>
Для обеспечения совместной работы классов, интерфейсы которых не совместимы.

**Пример использования** <br/>
- интерфейс класса, который мы хотим использовать не соответствует нашим потребностям;
- необходим класс, который должен взаимодействовать с классами, которые ему неизвестны или не связаны с ним;
- необходимо использовать несколько существующих подклассов, 
  но нецелесообразно использовать методы этих классов создавая их новые подклассы.

***

[Фасад (Facade)](https://github.com/FessBoss/Design-Patterns/tree/main/Adapter-Facade) <br/>
**Цель:** <br/>
Предоставить унифицированный интерфейс вместо нескольких интерфейсов подсистемы.

**Для чего используется:** <br/>
Используется для определения интерфейса высокого уровня, который упрощает использование подсистемы.

**Пример использования** <br/>
- изолирование клиентов от компонентов подсистемы, упрощая работу с ней;
- необходимость ослабления связанности подсистемы с клиентами.

***

[Шаблонный метод (Template Method)](https://github.com/FessBoss/Design-Patterns/tree/main/TemplateMethod) <br/>
**Цель:** <br/>
Определение основы класса и создание возможности подклассам переопределять его части.

**Для чего используется:** <br/>
Определяет основу класса и позволяет подклассам переопределять некоторые его части не изменяя его структуру в целом.

**Пример использования** <br/>
- однократное использование различных частей класса, оставляя реализацию изменяющегося поведения на усмотрение подклассов;
- вычленение и локализация общего для всех подклассов поведения в родительском;
- управление расширениями подклассов.

***

[Итератор (Iterator)](https://github.com/FessBoss/Design-Patterns/tree/main/Iterator-Composite) <br/>
**Цель:** <br/>
Получение последовательного доступа ко всем элементам составного объекта

**Для чего используется:** <br/>
Для последовательного доступа ко всем элементам составного объекта, скрывая его внутреннее представление.

**Пример использования** <br/>
- различные виды обхода составного объекта;
- упрощенный доступ к составному объекту.

***

[Компоновщик (Composite)](https://github.com/FessBoss/Design-Patterns/tree/main/Iterator-Composite) <br/>
**Цель:** <br/>
Скомпонировать объекты в структуры по типу "дерева", позволяя клиентам единообразно трактовать отдельные и составные
объекты.

**Для чего используется:** <br/>
Для группировки мелких компонентов в более крупные, которые, в свою очередь, могут стать основой для еще более крупных
структур.

**Пример использования** <br/>
- для представления иерархии "часть - целое";
- мы хотим, чтобы клиенты одним способом трактовали как отдельные, так и составные объекты;

***

[Состояние (State)](https://github.com/FessBoss/Design-Patterns/tree/main/State) <br/>
**Цель:** <br/>
Управление поведением объекта в зависимости от состояния.

**Для чего используется:** <br/>
Позволяет нам управлять поведением объекта в зависимости от внутреннего состояния объекта. 

**Пример использования** <br/>
- поведение объекта зависит от его состояния и изменяется во время выполнения;
- когда встречается большое количество условных операторов, когда выбор ветви зависит от состояния объекта.