# Паттерны проектирования (Design patterns)

[Стратегия (Strategy)](https://github.com/FessBoss/Design-Patterns/tree/main/Strategy) <br/>
**Цель:** <br/>
Взаимозаменяемость семейства классов.

**Для чего используется:** <br/>
Определение семейства классов, инкапсулирование каждого из них и организация их взаимозаменяемости.

**Пример использования** <br/>
- есть несколько родственных классов, которые отличаются поведением;
- необходимо иметь несколько вариантов поведения;
- в классе есть данные, о которых должен знать клиент;
- с помощью условных операторов в классе определено большое количество возможных поведений.

***

[Наблюдатель (Observer)](https://github.com/FessBoss/Design-Patterns/tree/main/Observer) <br/>
**Цель:** <br/>
Определение зависимости "один ко многим" между объектами.

**Для чего используется:** <br/>
Определение зависимости "один ко многим" между объектами таким образом, что при изменении состояния одного объекта 
все зависящие от него объекты были уведомлены об этом и обновились.

**Пример использования** <br/>
- когда у модели имеются два аспекта, один из которых зависит от другого. 
  Инкапсулирование этих аспектов в разные классы позволяют использовать их независимо друг от друга;
- когда один объект должен оповещать другие и не делать предположений об этих объектах;
- ослабление связи между объектами.

***

[Декоратор (Decorator)](https://github.com/FessBoss/Design-Patterns/tree/main/Decorator) <br/>
**Цель:** <br/>
Динамическое добавление новых обязанностей объекту.

**Для чего используется:** <br/>
Используется в качестве альтернативы порождению подклассов для расширения функциональности.

**Пример использования** <br/>
- динамическое и понятное клиентам добавления обязанностей объектам;
- реализация обязанностей, которые могут быть сняты с объекта;
- расширение класса путём порождения подклассов невозможно по каким-либо причинам.

***

[Фабричный метод (Factory Method)](https://github.com/FessBoss/Design-Patterns/tree/main/Factory) <br/>
**Цель:** <br/>
Создание интерфейса, который создает объект. При этом, выбор того, экземпляр какого класса создавать остается за классами,
которые имплементируют данный интерфейс.

**Для чего используется:** <br/>
Для делигирования создания экземпляров другому классу.

**Пример использования** <br/>
- заранее неизвестно, экземпляры какого класса нужно будет создавать;
- класс спроектирован таким образом, что создаваемые им объекты имеют свойство определенного класса.

***

[Абстрактная Фабрика (Abstract Factory)](https://github.com/FessBoss/Design-Patterns/tree/main/Factory) <br/>
**Цель:** <br/>
Создание интерфейса, для создания множества взаимосвязанных или взаимозависимых объектов, без жесткой привязке к конкретным
классам.

**Для чего используется:** <br/>
Для создания множеств взаимосвязанных объектов.

**Пример использования** <br/>
- система не должна зависеть от метода создания, компоновки и представления входящих в нее объектов;
- входящие взаимосвязанные объекты должны использоваться вместе;
- система должна конфигурироваться одним из множеств объектов, из которых она состоит
- нам необходимо предоставить множество объектов, раскрывая только их интерфейсы, но не реализацию.

***

[Одиночка (Singleton)](https://github.com/FessBoss/Design-Patterns/tree/main/Singleton) <br/>
**Цель:** <br/>
Гарантировать, что у класса будет только один единственный экземпляр и к нему будет предоставлена глобальная точка 
доступа.

**Для чего используется:** <br/>
Для создания единственного экземпляра определенного класса. 

**Пример использования** <br/>
- необходим только один экземпляр класса, который доступен для всех клиентов
- единственный экземпляр должен наследоваться путем порождения подклассов, при этом, клиенты имеют возможность работать
  с классом-наследником без модификации своего кода;
